<!--  Git es un software de control de versiones, donde registraremos todos los sucesos realizados durante el tiempo de vida de un proyecto.

Para que sirve una bitacora:
1. Para tener un historial de viaje cronológico y ordenado
2. Para recordar eventos específicos de un viaje pasado
3. Experiencia documentada para que otros aprendan
4. Mejorar en los siguientes viajes


Características de una buena bitacora 
1. Cronológico (No debes anotar sucesos anteriores que se te hayan olvidado, por ejemplo si hoy en 16 anotar sucesos del día 14 esta mal)
2. Muchos registros (Registrar varios eventos al día será lo recomendable)
3. Eventos detallados


Git
Es un sistema de control de versiones (SCV) en otras palabras; administrar los cambios que sucenden en el código. 
GIT se utiliza en una terminal de comandos.

Si ves en la version de GIT 8.4.3
El primer dígito "8" se refiere a la versión mayor/versión actual que estamos utilizando
El segundo dítito "4" se refiere a la versión menor/ versión anterior solo se pueden realizar algunas configuraciones básicas pero que no afecten el total funcionamiento del software 
El tercer dítito "3" se refiere a la versión fix/ soluciona algunos inconvenientes menores sin generar una nueva versión mayor.


Algunos comandos son:

ctr + l   limpiar terminal 
clear     limpiar terminal

git -v (version)
git --version

ls es para listar lo que hay dentro de una carpeta (Los elementos que se encuentran dentro de una carpeta)
ls -la  listar todo (list all)

Una buena preactica es no utilizar espacios ni caracteres especiales al nombrar archivos y carpetas en GIT nos servirá para navegar entre carpetas (Se crea la carpeta git-desde-cero)
GIT podría no dejarte entrar a una carpeta o navegar entre ellas, si el nombre se encuentra con espacios o carácteres extraños. 



Repositorio 
Es el lugar donde se va a guardar todo el historial de cambios que realicé en mi código.

git init  significa git initializer para crear un nuevo repositorio por cada proyecto; aparecera una nueva carpeta .git de manera oculta.

cd + nombre de la carpeta sirve para entrar a una carpeta desde la terminal o movernos a una carpeta en particular
cd sirve para salir de todas las carpetas



Git requiere de una configuracion donde le pongas tu nombre y correo para saber que persona realizó algún cambio


git config --global user.name "Erick J.P Ríos Preciado"  Esta configuracion estará guardada de manera global por defecto  y se utilizará para todo los proyectos y sistema operativo. Solo dar enter para guardar.
git config --global user.email "sensa_ios@hotmail.com"   Dar enter
git config --global core.edit "vim"   Configuracion del editor por defecto

Para saber si fue guardada dicha configuracion
git config user.name
git config user.email
git config core.edit


git config --help Para saber que configuraciones se pueden realizar (Se abrirá en un navegador) ó git config -h (se abrirá en consola git)
tambien se puede usar
git --help y git -h y podrás observar algunos comandos comunmente utilizados



Git status
Si ya estás dentro de la carpeta " Desktop/GIT/git-desde-cero" puedes colocar el comando "git status" donde saldrá un mensaje que dice: Untraked files (Archivos sin seguimiento) y aparecera mi archivo Git.html en color rojo.
Para que git detecte los cambios en las versiones le tienes que presentar el archivo (git add) o borrarlo (git rm).

en esa misma parte abajo se señala "No hay nada agregado al commit pero hay archivos sin seguimientos presentes, usa (git add para hacer seguimiento)"

Git add (agregar)
Con git add le presentaremos a git el arvhivo Git.html
entonces colocaremos git add Guit.html y enter.

si volvemos a llamar git status aprecera el mensaje  "Changes to be committed" (Cambios a ser confirmados) en color verde.


Git commit (confirmar)
Sirve para  confirmar los cambios y guardarlos; se debe agregar un mensaje muy claro (al ya haber sido presentado a git el archivo Git.html) 

git commit -m "Se crea el archivo Git.html que será la página inicial del sitio web"      Dentro de las comillas poner el mensaje (-m significa mensaje)


Comandos extras

open .   Abrir carpeta
code .   Abrir código en visual studio code
git rm (remove)
git log





                                            3 Areas de Git
1. Working directory (area de trabajo) Todos los archivos que tienes en el proyecto.
2- Stage area (Área de preparación) Sirve para agregar los cambios que hemos realizado en nuestro directorio de trabajo.
    En esta área podemos administrar los cambios que requieren ser confirmados para que lleguen al repositorio; si existe algún cambio que no esté correcto en este punto lo podemos remober.
3. Local repository (repositorio) Cuando los archivos ya están confirmados y pasan a ser almacenados en el repositorio.
  A partir de ese momento qualquier otro cambio en el directorio se considera un nuevo cambio que debera agregarse a tu área de preparación y luego al área de repositorio.

  Entonces el flujo sería: Directorio de trabajo (Todos los archivos) -> Area de preparación (Archivos que se requiere que sean confirmados o remoberlo) -> repositorio.

El comando git add envía la información del directorio de trabajo al área de preparación.
El comando git commit envía la información del área de preparación al repositorio.


En visual studio code podrás ver una linea verde cuando agregas un nuevo cambio, una linea roja cuando eliminas un linea o cambio de código y una rayada cuando se realizó una modificación.
Además, el título del archivo se coloca en amarillo y en el listado de archivos se observa una letra M (modificado) esto en VS code.



Si creamos en el HTML una etiqueta <link rel="stylesheet" href="Git.css"> y además generamos ese archivo CSS, nos saldrá en la lista de archivos la letra U (Untraked = sin seguimiento) ya que ese archivo Git.css aún no ha sido agregado en nuestro repositorio.
Si colocamos en la terminar git status nos saldrá el archivo Git.html modificado y en otra linea el archivo Git.css que creamos, los cuales podemos agregar a nuestra área de preparación con git add Git.html 
git status
git commit -m "Se agregó un título, se agregó una hoja CSS y se agregó un párrafo" enter
Saldrá la leyenda [master 4e6b201] cada confirmación tiene un número alfanumerico
git status





                                 Stage y Commit
Otra forma de pasar del directorio de trabajo al área de preparacion puede ser pasar una carpeta completa y no solo un archivo;
por lo que creamos una carpeta imagenes y agregamos unas imagenes dentro de la carpeta, colocamos git status en consola y hace referencia a toda la carpeta de imagenes y no una imagen en particular.
git add Imagenes/          tambien  podemos poner   git add . (El punto se refiere a una carpeta) esto funciona cuando estás dentro de una carpeta se tomara todos los elementos que contiene dicha carpeta.
otra opción para agregar todo de una vez al área de preparacion es  git add -A (No importa si estás dentro de una carpeta o subcarpeta todo se pasará al área de preparación)
git status
al pasar del área de preparación al repositorio (git commit -m "") las imagenes no se consideraran como lineas de insersion, ya que no es un código.
git log (Muestra el historial de cambios); para salir de la pantalla de log es con la tecla q


Revertir cambios del área de stage.
Si tenemos cambios en stage area y hay algunos documentos incorrectos podemos sacarlos con el comando
 git restore --staged Git.css (un archivo en concreto o carpeta completa)

Con el comando git checkout Git.css (archivo en concreto o carpeta completa) podemos restaurar la versión anterior si dicho arcvhivo se encuentra dentro del área de trabajo.
 *La versión anterior es la que ya se confirmo con un commit anteriormente, esta version confirmada ya no se puede modificar por más git checkout que pongamos)





                                    Entendimiento del Commit y del log

Al colorar en consola git log te saldrán todos commits que se han guardado en la cual tienen un ID alfanumérico, sin embargo, para hacer referencia a un commit en específico,
deberíamos de utilizar un aproximado de 6 a 7 dígitos más menos; además en el commit aparecerá información como del autor, día y el mensaje del commit.
colocamos la letra q para salir del log
y utilizamos el comando git show y el número de ID (4fd3821432) y enter.
saldrá informacion como: diff --git a/Git.html b/Git.html  que significa que archivos fueron modificados y guardados en el commit. Además
de informacion de las lineas nuevas agregadas, borradas y modificadas.



Git log
git log puede contener miles de commit agregados en el proyecto pero git te da una opcion de verlos más fácilmentes 
Para no ver todos los commits del log se tiene el comando git log --oneline que mostrará los ID por cada commit y las notas agregadas.


otra opción muy buena sería utilizar el comando
git log --oneline Git.css

otra opción podría ser si quiero saber todos los commits que se han creado por autor, el comando sería
git log --oneline --author="Erick J.P Ríos Preciado"


podríamos combinarlos como a continuación:
 git log --author="Erick J.P Ríos Preciado" Git.css
 git log --oneline --autor="Erick J.P Ríos Preciado" Git.css
 git log --autor="Erick J.P Ríos Preciado" --oneline


 otro comando que nos ayuda a buscar "por palabra" agragada en la nota sería:
 git log --oneline --grep="estilos"                      la palabre a buscar entre comillas.



                            Viajar en el tiempo con git
Para viajar en el tiempo con git se utiliza el siguiente comando: git checkout (número de commit).
La consideración para viajar en el tiempo es que no tengas archivos en el area de trabajo y area de preparación (En caso contrario saldrá un error); por lo que autorizas los documentos hasta el commit o los borras.                         

El viaje en el tiempo es literal, al escoger un cambio te transaladas a ese punto en éspecífico por lo que si hoy en día supongamos tienes 10 commits y viajas en el tiempo al segundo commit, solo verás el código como estuvo en ése momento (solo verás 2 commits en Git y VS code solo te mostrará la información que tenías en ese momento)

para volver al presente se utiliza el siguient comando: git checkout master




                                 Las Ramas de GIT
si utilizamos el siguiente comando git log --oneline --graph aparecerán los commits con un asterisco

Los asteriscos representan los commits y las líneas representan las ramas (Linea temporal en la que estamos trabajando)

*Commit más reciente
|
*
|
*
|
*Primer commit


La rama que creamos con git init (inicial) se llama rama master; en algunos proyectos se llamara rama main.

Rama Main
|
|   Nueva rama  (Nueva linea de tiempo independiente de la rama main; además tendrá sus propios commits)
| / 
|/
*Commit más reciente
|
*

La rama main puede seguir creciendo en paralelo mientras la nueva rama crea sus propios commits.





                                        Ver la rama con la que estoy trabajando
con git branch obtememos un listado de todas las ramas que tiene nuestro proyecto aparecerá *master
el asterisco señalara la rama en la que estás trabajando actualmente.



                                         Crear nuevas ramas
git checkout -b (nombre de la nueva rama) en este ejemplo la nueva rama la llamaremos dev, entonces quedaría
git checkout -b dev            en git ya aparecerá la rama con la que estas trabajando


Podemos llamar a git branch para ver la rama que estamos utilizando con *
después podemos llamar a git log --oneline --graph donde aparentemente no hay alguna diferencia, sin embargo, en uno de los commits aparecerá head -> dev, master 
quiere decir que nuestra área de trabajo "Head" esta apuntando a dos ramas, la rama dev y la rama master.



                                            Borrar una rama
git branch -d (nombre de la rama a eliminar)
git branch -d dev

Para borrar una rama no debemos estar utilizando esa rama, por lo que debemos cambiar de rama para borrarla.
por lo que podemos regresar a la rama master con el comando: git checkout (nombre de la rama).
por lo que quedaría como git checkout master
y ahora si podemos colocar git branch -d dev                             (- d significa delete)


    Segunda forma para cambiar de rama es con el comando:
git switch - c dev             (-c significa create) + (nombre de la rama) por lo que el significado es creo una rama y me moveré a esa rama.
*Se intenta poner un standar para que switch sea el único método para cambiar y crear una rama, aunque es más utilizado hoy día con checkout.

moverme a la rama master con el comando
git switch master 



                              Proporsito de tener ramas de trabajo
La rama main es con la que los usuarios ya están trabajando
nosotros como desarrollador utilizaremos una rama alternativa para realizar pruebas o rediseños; en este caso es nuestra rama dev
Si los cambios están correctos en dev y aprobados, podemos pasarlos a la rama master. (Se fucionan las ramas)

Creamos un nuevo archivo llamado README.MD (Markdown  = documento de texto simple)

con git status vemos los archivos que se van a requerir confirmar en el commit
por lo que los agregamos con git add Git.html, y git add Git.csss

Ya agregados esos cambios al stage esos dos archivos se pueden confirmar en un único commit
git commit -m "Se agregó imagen anime y se dio color al h1"       id commit 18dc8230d

Después se pasa el arcvhivo README.md al stage para ser confirmado posterior a ello en otro commit.
Si colocamos de nuevo git log podremos observar de donde empieza y termina la rama master y donde empieza y termina la rama dev
tambien podemos utilizar git log --oneline --graph


*En el código (VS code) si me muevo a la rama master el Readme me lo tachará ya que no existe el readme en la rama master.
además la informacion de los archivos Git.html Git.css donde se agregó el commit "Se agregó imagen anime y se dio color al h1" desaparecerá del código.
por lo que si quieres ver dicha información deverás volver a cambiar a la rama donde se agregaron esos cambios.






Fusionando ramas
Para fucionar los cambios yo necesito estar parado en la rama que está más abajo o más atras.

Si yo estoy parado en la rama dev y coloco el comando  git log --oneline --graph
la rama de abajo sería la rama master, por lo que debo cambiarme a la rama master con el comando git switch master.


Cuando ya estoy en la rama master estoy diciendo oye rama dev combinate con migo.
pero antes de fucionar las ramas podemos realizar una comparación entre ramas
por lo que utilizaremos el comando git diff dev (diff = diferencias) en este caso como ya estamos parados en la rama master solo especificaremos la rama a comparar dev.
nota extra: Se puede comparar de dev a master por igual de acuerda a la rama en que estemos parados.


Si estoy parado en la rama master y quiero que los cambios de dev se pasen a la rama master colocaré el siguiente comando.
git merge dev (merge=mesclar/fusionar)

aparecera algo así:
Updating 91064bd..a8ca79b
Fast-forward
 Git.css   |   3 ++                      (tres lineas nuevas)
 Git.html  | 112 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-
 README.md |   3 ++                      (Apareció un archivo readme con 3 lineas nuevas)
 3 files changed, 117 insertions(+), 1 deletion(-)
 create mode 100644 README.md             (Se creo el archivo readme.md)

Si estamos en la rama dev no debemos modificar para hacer alguna corrección por lo que se recomienda 
crear una nueva rama temporal llamada git switch -c fix/title-color

Con el siguiente comando podrás observar la bifurcación o las dos raices nuevas que salieron de dev
git log --oneline --all --graph

si utilizamos el comando git log --oneline --graph podremos observar que el commit a8ca79b  que antes solo existía en dev ahora se encuentra en la rama master.



Una buena practica es que la rama main no debería estar por delante de una rama secundaria ¿Por que? Por que la rama secundaria ha nacido de la rama original para poder crecer en paralelo,
la rama master hasta que no haya una funcion con esa rama, no debería seguir creciendo.
En otras palabras la rama secundaria debe seguir creciendo más que la rama master hasta que exista una fusión.


por lo que ahora cambiaremos a la rama dev y fusionaremos con git merge master (esto se realiza cuando la rama master está por encima de la dev)
ahora bien para ramas ya muy secudanrias podríamos borrar las ramas con git branch -d dev,
pero como ya habíamos fucionado el código antes a la rama master los cambios fucionados ya estan en master.
los commits de la rama dev que se borran ahora pertenecen a la rama master.




Entender que signigica la comparación al utilizar el comando git diff dev


diff --git a/Git.html b/Git.html                (muestra qué archivo se está comparando)
index 91ec8d9..ce6ffc0 100644                    metadatos del archivo (muestra los identificadores internos de Git para las versiones anterior y posterior)
--- a/Git.html                                     marcadores de archivo (indican los archivos "antes" y "después")
+++ b/Git.html
@@ -301,9 +301,30 @@                             (muestra las líneas afectadas) nota extra: Se puede comparar en ambos sentidos dev y master 
acuerda a la rama en



Ejercicios 
*Podemos tener la rama master(producción), la rama test (calidad), la rama dev (desarrollo).
Dichas ramas nunca debe ser modificadas o eliminadas directamente y solo deben recibir cambios
Por lo tanto debemos crear ramas temporales y trabajar sobre ellas 
por lo que para crear una rama temporal de dev debemos primero estár posicionados en la rama dev y despues crear una rama temporal como git switch -c feature/contact-page (Aquí se desarrollará todo el código para una página de contactos)


El único proposito de test es recibir informacion de la rama dev y el proposito de master es recibir la informacion de test.
con la tecla tab se puede autocompletar un contenido, si estamos en alguna rama como dev y colocamos git branch -d feature(tab) se completará la información.

cuando un cambio se ha quedado muy abajo (por retraso) podría salir un mensaje en MINGW64, vim ó VS code como el siguiente:


Mensaje:
Merge branch 'feature/contact-page' into dev
# Please enter a commit message to explain why this merge is necessary,
# especially if it merges an updated upstream into a topic branch.
#
# Lines starting with '#' will be ignored, and an empty message aborts
# the commit.


Para ese caso deberia guardarse con contol + s
para MINGW64 ó vim es utilizar :wq  (write quite) enter


                         Git Hub (Proyectos de repositorios en la nube)

El primer comando para sincronizacion sería git remote -v (sirve para verificar si mi carpeta ya está sincronizada con algun repositorio de la nube) sincronizar es como enlazar para posterior subir o bajar archivos
remote = Lugares donde mi proyecto está sincronizado
para agregarlo a la nube el comando será:   git remote add origin + (ruta http de github) 
Por estandar el primer remoto debemos llamarlo origin (carpeta en la nube), los posteriores remoto puedes llamarlos como gustes. 
quedaría como: git remote add origin https://github.com/Erick-JP-RP/First-GitHub.git y enter

despues consultamos de nuevo con el comando git remote -v y saldrán los siguientes lugares:

origin  https://github.com/Erick-JP-RP/First-GitHub.git (fetch)     este lugar me sirve para traer informacion
origin  https://github.com/Erick-JP-RP/First-GitHub.git (push)      este lugar me sirve para enviar informacion

ahora colocaremos el comando git push origin master (push es para enviar la informacion a la nube, el origin es para especificar el lugar donde sera guardada la informacion en la nube y master de que rama queremos enviar la informacion a la nube) enter
despues me pedirá mi usuario y contraseña de github (se puede generar un token desde github en Setting -> developper settings-> Personal access tokens)
también puede ser que desde el comando utilizado te de la opción de logearte por web.


al finalizar me saldrá algo como esto:

$ git push origin master
info: please complete authentication in your browser...
Enumerating objects: 72, done.
Counting objects: 100% (72/72), done.
Delta compression using up to 4 threads
Compressing objects: 100% (67/67), done.
Writing objects: 100% (72/72), 1.24 MiB | 159.00 KiB/s, done.
Total 72 (delta 25), reused 0 (delta 0), pack-reused 0 (from 0)
remote: Resolving deltas: 100% (25/25), done.
To https://github.com/Erick-JP-RP/First-GitHub.git
 * [new branch]      master -> master



Nota de stackoverflow
Siempre en un repositorio tienes una rama oculta, que puedes ver al usar git branch -a 
Esa rama oculta es origin/master.
Tú al usar git fetch, bajas los cambios del repositorio remoto a la rama origin/master. (git fetch origin)
Ahora ya tienes los cambios en origin/master, pero tendrías que pasarlos a la rama master, para eso tienes que usar: git merge origin/master




                                             Dashboard de proyecto en Github

Se recomienda subri las ramas a Github de una en una
git push origin test
git push origin dev 

En github puedes observar la rama master que está por defecto, las ramas secundarias (test y dev) y las ramas activas (Las ramas se pueden activar y desactivar)


En consola cambiamos a la rama dev y colocaremos git log --oneline --graph y se verá lo siguiente:
 7d63eec (HEAD -> dev, origin/test, origin/master, origin/dev, test, master)

 En total son 6 ramas (3 locales y 3 de la nube)


Crearemos una etiquete en el HTML y guardaremos hasta un commit en la rama dev,
si volvemos a colocar git log --oneline --graph la carpeta local dev irá por delante de las demás ramas; en especial de la rama remota (origin dev)
por lo que tendremos que sincronizarlo con git push origin dev.   (lo que se envía es la rama local dev a github y con eso ya está sincronizado)
se vera en consolo ahora así:

b5d87e9 (HEAD -> dev, origin/dev)  en este caso la rama local y la rama de la nube están sincronizadas.



En github saldrá un mensaje donde señala que la rama dev ha sufrido cambios hace tantos minutos, ahí mismo en github se ve un botón donde puedes hacer la comparacion y combinar esas ramas.
En github podremos mesclar las ramas con el botón de pull request (solicitud de jalar cambios)test absorvera los cambios de dev
al oprimir el pull request de la notificacion aparecerá de que rama a que rama vas a fusionar, además comparará el código de ambas ramas.
para finalizar oprimir el botón de create pull request, git hub te dirá si los cambios se podrán realizar, en caso afirmativo oprimir el botón merge pull request y despues confirm merge.

En el ejemplo anterior se mescló la rama dev a la rama test en github, pero la rama test en consola (maquina local) aún no tiene ese cambio.
vamos a la rama test y podemos utilizar el comando git remote -v y utilizar la opción (fetch),
antes de traer los cambios podemos usar el comando git log --oneline --graph y veremos que la rama test "aparentemente están al día y sincronizados"
ahora usamos el comando git fetch  (se traerá la informacion de github al local)
si colomamos git log --oneline --graph observaremos que la rama test está por delante de la rama local test y esto nunca debe de pasar
por lo que utilizararemos el comando  git pull origin test    (pull jala la informacion de github y actualiza la rama local)

nota: fetch solo trae la informacion al área local PERO no actualiza las ramas locales.


por lo que si colocomos de nuevo git log --oneline  --graph se verán las ramas sincronizadas test -> origin, test dev-> origin dev









                                         Ignorando archivos y clonando repositorios
si coloco git fetch y no hay informacion nueva no me traerá nada la consola, pero si coloco git pull origin test le estoy diciendo traeme los cambios.
En este ejemplo ya está actualizado por lo que saldrá el mensaje:

From https://github.com/Erick-JP-RP/First-GitHub
 * branch            test       -> FETCH_HEAD
Already up to date.

si coloco git push origin test y no hay nada nuevo, por igual saldrá un mensaje donde señala que todo ya está actualizado.
ahora cambiaremos a la rama dev
y craremos un archivo nuevo llamado .gitignore (se coloca en automatico el simbolo de git)


el archivo .gitignore sirve para poder listar todo lo que quiera que ignore git y no lo considere parte del repositorio.
ej estos archivos, estas carpetas no los tomes en cuenta.

crearemos un nuevo arvhico llamado privado.md y colocamos en consola git status, saldrán los nuevos archivos creados.
por lo que si queremos ignorar el arvhivo privado.md debemos ir al archivo .gitignore y colocar
privado.md y guardar, se observará que el archivo privado.md aparecerá como en letras grises y ya no se verá en color verde con la letra U.
si en consola vuelves a poner git status solo aparecerá un archivo que es el .gitignore

también podrías ignorar todos los archivos .md, por lo que tendrías que poner *.md (En ocasiones si los archivos como .md ya habían sido seguidos por git, no te los colocará en gris, por lo que tendrías que vaciar la cache de git)



Por lo tanto:

privado.md           especificamos el archivo a ignorar
*.md                 ignoramos todos los archivos .md
/privados            ignoramos una carpeta












-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="Git.css">
    <title>Prueba GIT</title>
</head>
<body>
    <h1 class="title">Prueba de GIT</h1>
    <p>Éste es un cambio en el párrafo 12</p>
    <img src="Imagenes/anime-girl.jpg" alt="">

<a href="contact.html">Contactanos</a>

</body>
</html>